<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Loop.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Test</a> &gt; <a href="index.source.html" class="el_package">Lesson3</a> &gt; <span class="el_source">Loop.java</span></div><h1>Loop.java</h1><pre class="source lang-java linenums">package Lesson3;

import Lesson1.Task1;

<span class="fc" id="L5">public class Loop {</span>

<span class="fc" id="L7">    Task1 task1 = new Task1();</span>

    /**
     * Пример
     * &lt;p&gt;
     * Вычисление факториала
     */
    double factorial(int n) {
<span class="fc" id="L15">        double result = 1.0;</span>
<span class="fc bfc" id="L16" title="All 2 branches covered.">        for (int i = 1; i &lt;= n; i++) {</span>
<span class="fc" id="L17">            result *= i;// Please do not fix in master</span>
        }
<span class="fc" id="L19">        return result;</span>
    }


    /**
     * Пример
     * &lt;p&gt;
     * Проверка числа на простоту -- результат true, если число простое
     */
    boolean isPrime(int n) {
<span class="fc bfc" id="L29" title="All 2 branches covered.">        if (n &lt; 2) return false;</span>
<span class="fc bfc" id="L30" title="All 2 branches covered.">        if (n == 2) return true;</span>
<span class="fc bfc" id="L31" title="All 2 branches covered.">        if (n % 2 == 0) return false;</span>
<span class="fc bfc" id="L32" title="All 2 branches covered.">        for (int m = 3; m &lt;= Math.sqrt(n); m+=2) {</span>
<span class="fc bfc" id="L33" title="All 2 branches covered.">            if (n % m == 0) return false;</span>
        }
<span class="fc" id="L35">        return true;</span>
    }


    /**
     * Пример
     * &lt;p&gt;
     * Проверка числа на совершенность -- результат true, если число совершенное
     */
    boolean isPerfect(int n) {
<span class="fc" id="L45">        int sum = 1;</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">        for (int m = 2; m &lt; n; n /= 2) {</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">            if (n % m &gt; 0) continue;</span>
<span class="fc" id="L48">            sum += m;</span>
<span class="fc" id="L49">            m++;</span>
        }
<span class="fc bfc" id="L51" title="All 2 branches covered.">        return sum == n;</span>
    }


    /**
     * Пример
     * &lt;p&gt;
     * Найти число вхождений цифры m в число n
     */
    int digitCountInNumber(int n, int m) {
<span class="fc bfc" id="L61" title="All 2 branches covered.">        if (n == m) return 1;</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">        else if (n &lt; 10) return 0;</span>
<span class="fc" id="L63">        else return digitCountInNumber(n / 10, m) + digitCountInNumber(n % 10, m);</span>
    }


    /**
     * Простая
     * &lt;p&gt;
     * Найти количество цифр в заданном числе n.
     * Например, число 1 содержит 1 цифру, 456 -- 3 цифры, 65536 -- 5 цифр.
     * &lt;p&gt;
     * Использовать операции со строками в этой задаче запрещается.
     */
    int digitNumber(int n) {
<span class="fc" id="L76">        int digit = n;</span>
<span class="fc" id="L77">        int k = 0;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        if (digit == 0) {</span>
<span class="fc" id="L79">            return 1;</span>
        } else {
<span class="fc bfc" id="L81" title="All 2 branches covered.">            while (digit != 0) {</span>
<span class="fc" id="L82">                digit /= 10;</span>
<span class="fc" id="L83">                k++;</span>
            }
<span class="fc" id="L85">            return k;</span>
        }
    }


    /**
     * Простая
     * &lt;p&gt;
     * Найти число Фибоначчи из ряда 1, 1, 2, 3, 5, 8, 13, 21, ... с номером n.
     * Ряд Фибоначчи определён следующим образом: fib(1) = 1, fib(2) = 1, fib(n+2) = fib(n) + fib(n+1)
     */
    int fib(int n) {
<span class="fc" id="L97">        int fib_n = 1;</span>
<span class="fc" id="L98">        int fib_n1 = 1;</span>
<span class="fc" id="L99">        int fib_n2 = 0;</span>
<span class="fc bfc" id="L100" title="All 4 branches covered.">        if (n &gt;= 1 &amp;&amp; n &lt;= 2) {</span>
<span class="fc" id="L101">            return 1;</span>
        }
<span class="fc bfc" id="L103" title="All 2 branches covered.">        for (int i = 3; i &lt;= n; i++) {</span>
<span class="fc" id="L104">            fib_n2 = fib_n + fib_n1;</span>
<span class="fc" id="L105">            fib_n = fib_n1;</span>
<span class="fc" id="L106">            fib_n1 = fib_n2;</span>
        }
<span class="fc" id="L108">        return fib_n2;</span>
    }


    /**
     * Простая
     * &lt;p&gt;
     * Для заданных чисел m и n найти наименьшее общее кратное, то есть,
     * минимальное число k, которое делится и на m и на n без остатка
     */
    int lcm(int m, int n) {
<span class="fc" id="L119">        int num_m = m;</span>
<span class="fc" id="L120">        int num_n = n;</span>
<span class="fc" id="L121">        int multiplication = (num_m * num_n);</span>
<span class="fc bfc" id="L122" title="All 4 branches covered.">        while ((num_m != 0) &amp;&amp; (num_n != 0)) {</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">            if (num_m &gt; num_n) num_m %= num_n;</span>
<span class="fc" id="L124">            else num_n %= num_m;</span>
        }
<span class="fc" id="L126">        int count = num_m + num_n;</span>
<span class="fc" id="L127">        return multiplication / count;</span>
    }


    /**
     * Простая
     * &lt;p&gt;
     * Для заданного числа n &gt; 1 найти минимальный делитель, превышающий 1
     */
    int minDivisor(int n) {
<span class="fc" id="L137">        int k = 2;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        while (n % k != 0) {</span>
<span class="fc" id="L139">            k++;</span>
        }
<span class="fc" id="L141">        return k;</span>
    }


    /**
     * Простая
     * &lt;p&gt;
     * Для заданного числа n &gt; 1 найти максимальный делитель, меньший n
     */
    int maxDivisor(int n) {
<span class="fc" id="L151">        int k = n - 1;</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">        while (n % k != 0) {</span>
<span class="fc" id="L153">            k--;</span>
        }
<span class="fc" id="L155">        return k;</span>
    }


    /**
     * Простая
     * &lt;p&gt;
     * Определить, являются ли два заданных числа m и n взаимно простыми.
     * Взаимно простые числа не имеют общих делителей, кроме 1.
     * Например, 25 и 49 взаимно простые, а 6 и 8 -- нет.
     */
    boolean isCoPrime(int m, int n) {
<span class="fc" id="L167">        int del = 2;</span>
<span class="fc" id="L168">        int count = 1;</span>
<span class="fc" id="L169">        int max = Math.max(m, n);</span>

<span class="fc bfc" id="L171" title="All 4 branches covered.">        while (count == 1 &amp;&amp; del &lt; max) {</span>
<span class="fc bfc" id="L172" title="All 4 branches covered.">            if (m % del == 0 &amp;&amp; n % del == 0) {</span>
<span class="fc" id="L173">                count++;</span>
            }
<span class="fc" id="L175">            del++;</span>
        }
<span class="fc bfc" id="L177" title="All 2 branches covered.">        return count == 1;</span>
    }


    /**
     * Простая
     * &lt;p&gt;
     * Для заданных чисел m и n, m &lt;= n, определить, имеется ли хотя бы один точный квадрат между m и n,
     * то есть, существует ли такое целое k, что m &lt;= k*k &lt;= n.
     * Например, для интервала 21..28 21 &lt;= 5*5 &lt;= 28, а для интервала 51..61 квадрата не существует.
     */
    boolean squareBetweenExists(int m, int n) {
<span class="fc" id="L189">        int left = (int) Math.sqrt(m);</span>
<span class="fc" id="L190">        int right = (int) Math.sqrt(n);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        for (int i = left; i &lt;= right; i++) {</span>
<span class="pc bpc" id="L192" title="1 of 4 branches missed.">            if (task1.sqr(i) &gt;= m &amp;&amp; task1.sqr(i) &lt;= n) {</span>
<span class="fc" id="L193">                return true;</span>
            }
        }
<span class="fc" id="L196">        return false;</span>
    }


    /**
     * Средняя
     * &lt;p&gt;
     * Гипотеза Коллатца. Рекуррентная последовательность чисел задана следующим образом:
     * &lt;p&gt;
     * ЕСЛИ (X четное)
     * Xслед = X /2
     * ИНАЧЕ
     * Xслед = 3 * X + 1
     * &lt;p&gt;
     * например
     * 15 46 23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1 4 2 1 4 2 1 ...
     * Данная последовательность рано или поздно встречает X == 1.
     * Написать функцию, которая находит, сколько шагов требуется для
     * этого для какого-либо начального X &gt; 0.
     */
    int collatzSteps(int x) {
<span class="fc" id="L217">        int digit = x;</span>
<span class="fc" id="L218">        int steps = 0;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        while (digit != 1) {</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (digit % 2 == 0) {</span>
<span class="fc" id="L221">                digit /= 2;</span>
            } else {
<span class="fc" id="L223">                digit = 3 * digit + 1;</span>
            }
<span class="fc" id="L225">            steps++;</span>
        }
<span class="fc" id="L227">        return steps;</span>
    }


    /**
     * Средняя
     * &lt;p&gt;
     * Для заданного x рассчитать с заданной точностью eps
     * sin(x) = x - x^3 / 3! + x^5 / 5! - x^7 / 7! + ...
     * Нужную точность считать достигнутой, если очередной член ряда меньше eps по модулю.
     * Подумайте, как добиться более быстрой сходимости ряда при больших значениях x.
     * Использовать kotlin.math.sin и другие стандартные реализации функции синуса в этой задаче запрещается.
     */
    double sin(double x, double eps) {
<span class="fc" id="L241">        int number = 1;</span>
<span class="fc" id="L242">        int digit = 3;</span>
<span class="fc" id="L243">        double xx = (x % (2 * Math.PI));</span>
<span class="fc" id="L244">        double absEps = Math.abs(eps);</span>
<span class="fc" id="L245">        double sin = xx;</span>
<span class="fc" id="L246">        double currentExp = xx;</span>
<span class="fc" id="L247">        double part = xx;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        while (Math.abs(part) &gt;= absEps) {</span>
<span class="fc" id="L249">            currentExp *= xx * xx;</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (number % 2 != 0) part = (-1 * currentExp / factorial(digit));</span>
<span class="fc" id="L251">            else part = (currentExp / factorial(digit));</span>
<span class="fc" id="L252">            sin += part;</span>
<span class="fc" id="L253">            number += 1;</span>
<span class="fc" id="L254">            digit += 2;</span>
        }
<span class="fc" id="L256">        return sin;</span>
    }


    /**
     * Средняя
     * &lt;p&gt;
     * Для заданного x рассчитать с заданной точностью eps
     * cos(x) = 1 - x^2 / 2! + x^4 / 4! - x^6 / 6! + ...
     * Нужную точность считать достигнутой, если очередной член ряда меньше eps по модулю
     * Подумайте, как добиться более быстрой сходимости ряда при больших значениях x.
     * Использовать kotlin.math.cos и другие стандартные реализации функции косинуса в этой задаче запрещается.
     */
    double cos(double x, double eps) {
<span class="fc" id="L270">        double cos = 1.0;</span>
        double part;
<span class="fc" id="L272">        int number = 1;</span>
<span class="fc" id="L273">        int digit = 2;</span>
<span class="fc" id="L274">        double xx = x % (2 * Math.PI);</span>
<span class="fc" id="L275">        double absEps = Math.abs(eps);</span>
<span class="fc" id="L276">        double currentExp = 1.0;</span>
        do {
<span class="fc" id="L278">            currentExp *= xx * xx;</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">            if (number % 2 != 0) part = -1 * currentExp / factorial(digit);</span>
<span class="fc" id="L280">            else part = currentExp / factorial(digit);</span>
<span class="fc" id="L281">            cos += part;</span>
<span class="fc" id="L282">            number += 1;</span>
<span class="fc" id="L283">            digit += 2;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">        } while (Math.abs(part) &gt;= absEps);</span>
<span class="fc" id="L285">        return cos;</span>
    }


    /**
     * Средняя
     * &lt;p&gt;
     * Поменять порядок цифр заданного числа n на обратный: 13478 -&gt; 87431.
     * &lt;p&gt;
     * Использовать операции со строками в этой задаче запрещается.
     */
    int revert(int n) {
<span class="fc" id="L297">        int revert = 0;</span>
<span class="fc" id="L298">        int temp = n;</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (n &lt; 0) {</span>
<span class="fc" id="L300">            temp *= -1;</span>
        }
<span class="fc bfc" id="L302" title="All 2 branches covered.">        while (temp &gt; 0) {</span>
<span class="fc" id="L303">            revert = revert * 10 + temp % 10;</span>
<span class="fc" id="L304">            temp /= 10;</span>
        }
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (n &lt; 0)</span>
<span class="fc" id="L307">            return revert * -1;</span>
<span class="fc" id="L308">        else return revert;</span>
    }


    /**
     * Средняя
     *
     * Проверить, является ли заданное число n палиндромом:
     * первая цифра равна последней, вторая -- предпоследней и так далее.
     * 15751 -- палиндром, 3653 -- нет.
     *
     * Использовать операции со строками в этой задаче запрещается.
     */
<span class="fc bfc" id="L321" title="All 4 branches covered.">    boolean isPalindrome(int n) { return n&gt;=0 &amp;&amp; n == revert(n);}</span>



    /**
     * Средняя
     *
     * Для заданного числа n определить, содержит ли оно различающиеся цифры.
     * Например, 54 и 323 состоят из разных цифр, а 111 и 0 из одинаковых.
     *
     * Использовать операции со строками в этой задаче запрещается.
     */
    boolean hasDifferentDigits(int n) {
<span class="fc" id="L334">        int lastDigit = n % 10;</span>
<span class="fc" id="L335">        int digit = (n - lastDigit) / 10;</span>
<span class="fc bfc" id="L336" title="All 4 branches covered.">        if (n&gt;=-9&amp;&amp;n&lt;=9) {</span>
<span class="fc" id="L337">            return false;</span>
        }
<span class="fc bfc" id="L339" title="All 2 branches covered.">        if (n &lt; 0) {</span>
<span class="fc" id="L340">            return true;</span>
        }
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (digitNumber(n) == 2) {</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            return lastDigit != digit;</span>
        } else {
<span class="fc" id="L345">            int penultimateDigit = digit % 10;</span>
<span class="fc" id="L346">            digit = (digit - penultimateDigit) / 10;</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">            while (digit != 0) {</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                if (lastDigit != penultimateDigit) {</span>
<span class="fc" id="L349">                    return true;</span>
                }
<span class="fc" id="L351">                penultimateDigit = digit % 10;</span>
<span class="fc" id="L352">                digit = (digit - penultimateDigit) / 10;</span>
            }
        }
<span class="fc" id="L355">        return false;</span>
    }


    /**
     * Сложная
     *
     * Найти n-ю цифру последовательности из квадратов целых чисел:
     * 149162536496481100121144...
     * Например, 2-я цифра равна 4, 7-я 5, 12-я 6.
     *
     * Использовать операции со строками в этой задаче запрещается.
     */
    int squareSequenceDigit(int n) {
<span class="fc" id="L369">        int digit = 0;</span>
<span class="fc" id="L370">        int number = 1;</span>
<span class="fc" id="L371">        int square = 1;</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        while (digit != n) {</span>
<span class="fc" id="L373">            square = number * number;</span>
<span class="fc" id="L374">            digit += digitNumber(square);</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">            while (n &lt; digit) {</span>
<span class="fc" id="L376">                square /= 10;</span>
<span class="fc" id="L377">                digit--;</span>
            }
<span class="fc" id="L379">            number++;</span>
        }
<span class="fc" id="L381">        return square % 10;</span>
    }


    /**
     * Сложная
     *
     * Найти n-ю цифру последовательности из чисел Фибоначчи (см. функцию fib выше):
     * 1123581321345589144...
     * Например, 2-я цифра равна 1, 9-я 2, 14-я 5.
     *
     * Использовать операции со строками в этой задаче запрещается.
     */
    int fibSequenceDigit(int n) {
<span class="fc" id="L395">        int digit = 0;</span>
<span class="fc" id="L396">        int number = 1;</span>
<span class="fc" id="L397">        int fib = 1;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        while (n != digit) {</span>
<span class="fc" id="L399">            fib = fib(number);</span>
<span class="fc" id="L400">            digit += digitNumber(fib);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            while (n &lt; digit) {</span>
<span class="fc" id="L402">                fib /= 10;</span>
<span class="fc" id="L403">                digit--;</span>
            }
<span class="fc" id="L405">            number++;</span>
        }
<span class="fc" id="L407">        return fib % 10;</span>
    }
}




</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>